#include <string.h>
#include <stdio.h>    
#include <stdlib.h>   
#include <stack>
#include <io.h>  
#include <math.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXSIZE 100 /* 存储空间初始分配量 */
using namespace std;
typedef int Status;		/* Status是函数的类型,其值是函数结果状态代码，如OK等 */


/* ************************************************ */

typedef char TElemType;
TElemType Nil=' '; /* 字符型以空格符为空 */

Status visit(TElemType e)
{
	printf("%c ",e);
	return OK;
}

typedef struct BiTNode  /* 结点结构 */
{
   TElemType data;		/* 结点数据 */
   struct BiTNode *lchild,*rchild; /* 左右孩子指针 */
}BiTNode,*BiTree;


/* 构造空二叉树T */
Status InitBiTree(BiTNode **T)
{ 
	*T=NULL;
	return OK;
}

/* 初始条件: 二叉树T存在。操作结果: 销毁二叉树T */
void DestroyBiTree(BiTree *T)
{ 
	if(*T) 
	{
		if((*T)->lchild) /* 有左孩子 */
			DestroyBiTree(&(*T)->lchild); /* 销毁左孩子子树 */
		if((*T)->rchild) /* 有右孩子 */
			DestroyBiTree(&(*T)->rchild); /* 销毁右孩子子树 */
		free(*T); /* 释放根结点 */
		*T=NULL; /* 空指针赋0 */
	}
}

/* 按前序输入二叉树中结点的值（一个字符） */
/* #表示空树，构造二叉链表表示二叉树T。 */
void CreateBiTree(BiTree *T)
{ 
	TElemType ch;	
	 scanf("%c",&ch); 
	if(ch=='#') 
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)->data=ch; /* 生成根结点 */
		CreateBiTree(&(*T)->lchild); /* 构造左子树 */
		CreateBiTree(&(*T)->rchild); /* 构造右子树 */
	}
 }

/* 初始条件: 二叉树T存在 */
/* 操作结果: 若T为空二叉树,则返回TRUE,否则FALSE */
Status BiTreeEmpty(BiTree T)
{ 
	if(T)
		return FALSE;
	else
		return TRUE;
}

#define ClearBiTree DestroyBiTree

/* 初始条件: 二叉树T存在。操作结果: 返回T的深度 */
int BiTreeDepth(BiTree T)
{
	int i,j;
	if(!T)
		return 0;
	if(T->lchild)
		i=BiTreeDepth(T->lchild);
	else
		i=0;
	if(T->rchild)
		j=BiTreeDepth(T->rchild);
	else
		j=0;
	return i>j?i+1:j+1;
}

/* 初始条件: 二叉树T存在。操作结果: 返回T的根 */
TElemType Root(BiTree T)
{ 
	if(BiTreeEmpty(T))
		return Nil;
	else
		return T->data;
}

/* 初始条件: 二叉树T存在，p指向T中某个结点 */
/* 操作结果: 返回p所指结点的值 */
TElemType Value(BiTree p)
{
	return p->data;
}

/* 给p所指结点赋值为value */
void Assign(BiTree p,TElemType value)
{
	p->data=value;
}
//节点数目 
int NodeNum(BiTree T)
{
	int i=0;
	if(T==NULL)
		return 0;
    else
    {
    	i = 1+ NodeNum(T->lchild)+NodeNum(T->rchild); 
    }
	return i;
}
/* 初始条件: 二叉树T存在 */
/* 操作结果: 前序递归遍历T */
int PreOrderTraverse(BiTree T)
{ 
	if(T==NULL)
		return 0;
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
	PreOrderTraverse(T->lchild); /* 再先序遍历左子树 */
	PreOrderTraverse(T->rchild); /* 最后先序遍历右子树 */
}

/* 初始条件: 二叉树T存在 */
/* 操作结果: 中序递归遍历T */
int InOrderTraverse(BiTree T)
{ 
	if(T==NULL)
		return 0;
	InOrderTraverse(T->lchild); /* 中序遍历左子树 */
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
	InOrderTraverse(T->rchild); /* 最后中序遍历右子树 */
}

/* 初始条件: 二叉树T存在 */
/* 操作结果: 后序递归遍历T */
int PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return 0;
	PostOrderTraverse(T->lchild); /* 先后序遍历左子树  */
	PostOrderTraverse(T->rchild); /* 再后序遍历右子树  */
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
}
//遍历二叉树的某层 
int Level(BiTree T, int level) 
{  
    if (!T || level < 0)  
        return 0;
	else if (level ==0)
	{
		printf("%c",T->data); 
		return 1;
	}  
	else 
        return Level(T->lchild, level - 1)+Level(T->rchild, level - 1); 
	
}
void InOrderTraverse_2(BiTree T)//非递归中序遍历  
{       
    stack<BiTree> Stack;  
    if(!T)  
    {  
        printf("空树！\n");  
        return;  
    }  
      
    while(T || !Stack.empty())  
    {  
//先入栈：若T为空也即不能入栈时则执行下面的出栈操作
        while(T)  
        {  
            Stack.push(T);  
            T=T->lchild;  
        }
//出栈：需判定出栈或标记  
        T=Stack.top();  
        Stack.pop();  
        printf("%c",T->data);  
//起到链接作用
        T=T->rchild;  
    }                                                                                                                                     
}  
  
  
  
void PreOrderTraverse_2(BiTree T)//非递归先序遍历  
{  
      
    stack<BiTree> Stack;  
    if(!T)  
    {  
        printf("空树！\n");  
        return;  
    }  
    while(T || !Stack.empty())  
    {  
//先入栈：若T为空也即不能入栈时则执行下面的出栈操作
        while(T)  
        {  
            Stack.push(T);  
            printf("%c",T->data);  
            T=T->lchild;  
        }  
//出栈：需判定出栈或标记
        T=Stack.top();  
        Stack.pop();  
//起到连接作用        
        T=T->rchild;          
    }                                                                                                                                     
}  
  
  
void PostOrderTraverse_2(BiTree T)//非递归后序遍历,用一个标记标记右子树是否访问过  
{    
    stack<BiTree> Stack;//声明节点栈 
	stack<int> Stack_2;  //声明标志栈 
	int flag;
	BiTree p =T; 
    while(p || !Stack.empty())//p指向为空且栈为空时所有元素遍历完成
	{
		if(p)//当树节点不为空时 一直往左遍历 
		{
			Stack.push(p);
			Stack_2.push(0);
			p=p->lchild;
		}
		else  //找到了最左的节点 
		{
			p=Stack.top();
			flag=Stack_2.top();
			if(!flag)  //给这些遍历过的点赋标志1 
			{
				Stack_2.pop();
				Stack_2.push(1);
				p=p->rchild;
			}
			else   //回到父节点 
			{
				p=Stack.top();
				Stack.pop();
				Stack_2.pop();
				printf("%c",p->data);
				p=NULL;
			}
		}
	}                                                                                                                                    
}  

//打印遍历的结果 
void LevelTraverse(BiTree T)
{
	int i=0;
	for (i=0;i<BiTreeDepth(T);i++)
	{
		Level(T,i);
	}
}
int main()
{
	int i;
	BiTree T;
	TElemType e1;
	InitBiTree(&T);

	
	//输入ABDH#K###E##CFI###G#J##

	CreateBiTree(&T);

	printf("构造空二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
	e1=Root(T);
	printf("二叉树的根为: %c\n",e1);
	printf("\n递归前序遍历二叉树:");
	PreOrderTraverse(T);
	printf("\n递归中序遍历二叉树:");
	InOrderTraverse(T);
	printf("\n递归后序遍历二叉树:");
	PostOrderTraverse(T);
	printf("\n非递归前序遍历二叉树:");
	PreOrderTraverse_2(T);
	printf("\n非递归中序遍历二叉树:");
	InOrderTraverse_2(T);
	printf("\n非递归后序遍历二叉树:");
	PostOrderTraverse_2(T);
	printf("\n层次遍历二叉树:");	
	LevelTraverse(T);
	printf("\n二叉树的节点数目为:");
	printf("%d",NodeNum(T));
	ClearBiTree(&T);
	printf("\n清除二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
	i=Root(T);
	if(!i)
	printf("树空，无根\n");
	
	return 0;
}

